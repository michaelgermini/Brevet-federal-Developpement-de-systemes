# Chapitre 1 : Comprendre le cycle de vie logiciel

> **Objectif:** Ma√Ætriser les diff√©rents mod√®les de cycle de vie logiciel, comprendre la gestion des exigences et √©tablir le lien entre analyse m√©tier et conception technique.

---

## üìã Table des mati√®res

1. [D√©finitions et terminologies cl√©s](#11-d√©finitions-et-terminologies-cl√©s)
2. [Cycle en V, mod√®le en spirale, et m√©thodes it√©ratives](#12-cycle-en-v-mod√®le-en-spirale-et-m√©thodes-it√©ratives)
3. [Gestion des exigences et cahier des charges](#13-gestion-des-exigences-et-cahier-des-charges)
4. [Lien entre analyse m√©tier et conception technique](#14-lien-entre-analyse-m√©tier-et-conception-technique)

---

## 1.1 D√©finitions et terminologies cl√©s

### 1.1.1 Qu'est-ce qu'un cycle de vie logiciel?

Le **cycle de vie logiciel** (Software Development Life Cycle - SDLC) repr√©sente l'ensemble des phases par lesquelles passe un syst√®me logiciel depuis sa conception jusqu'√† sa mise hors service. Il structure et organise le processus de d√©veloppement pour garantir la qualit√©, la tra√ßabilit√© et la maintenabilit√© du produit final.

**D√©finition formelle:**
> Le SDLC est un processus structur√© de planification, cr√©ation, test, d√©ploiement et maintenance d'un syst√®me d'information, visant √† produire un logiciel de haute qualit√© dans des d√©lais et budgets ma√Ætris√©s.

### 1.1.2 Les phases universelles d'un projet logiciel

Quel que soit le mod√®le choisi, tout projet logiciel traverse ces phases essentielles:

#### üìä Phase 1: Analyse et planification
- **√âtude de faisabilit√©:** √âvaluation technique, √©conomique et op√©rationnelle
- **Analyse des besoins:** Collecte et formalisation des attentes
- **Planification:** Estimation des ressources, d√©lais et co√ªts

**Livrables typiques:**
- Document de faisabilit√©
- √âtude d'opportunit√©
- Planning pr√©visionnel
- Budget pr√©visionnel

#### üé® Phase 2: Conception (Design)
- **Conception architecturale:** Structure globale du syst√®me
- **Conception d√©taill√©e:** Sp√©cifications techniques pr√©cises
- **Mod√©lisation:** Diagrammes UML, sch√©mas de bases de donn√©es

**Livrables typiques:**
- Document d'architecture technique
- Sp√©cifications fonctionnelles d√©taill√©es
- Mod√®les de donn√©es
- Diagrammes UML

#### üíª Phase 3: D√©veloppement (Impl√©mentation)
- **Codage:** √âcriture du code source
- **Int√©gration:** Assemblage des composants
- **Revue de code:** Contr√¥le qualit√© du code

**Livrables typiques:**
- Code source
- Documentation du code
- Scripts de d√©ploiement
- Biblioth√®ques et d√©pendances

#### ‚úÖ Phase 4: Tests et validation
- **Tests unitaires:** Validation des composants individuels
- **Tests d'int√©gration:** Validation des interactions
- **Tests syst√®me:** Validation globale
- **Tests d'acceptation:** Validation par les utilisateurs

**Livrables typiques:**
- Plans de tests
- Rapports de tests
- Listes de bugs et r√©solutions
- Certificat de recette

#### üöÄ Phase 5: D√©ploiement et mise en production
- **Pr√©paration de l'environnement:** Configuration serveurs, bases de donn√©es
- **Migration des donn√©es:** Transfert depuis l'ancien syst√®me
- **Formation des utilisateurs:** Documentation et sessions de formation
- **Go-live:** Bascule en production

**Livrables typiques:**
- Proc√©dures de d√©ploiement
- Documentation utilisateur
- Guides d'administration
- Plan de formation

#### üîß Phase 6: Maintenance et √©volution
- **Maintenance corrective:** Correction des bugs
- **Maintenance adaptative:** Adaptations √† l'environnement
- **Maintenance √©volutive:** Nouvelles fonctionnalit√©s
- **Maintenance pr√©ventive:** Optimisations et am√©liorations

**Livrables typiques:**
- Patches et mises √† jour
- Notes de version (release notes)
- Rapports d'incidents
- Plans d'√©volution

### 1.1.3 Terminologies essentielles

| Terme | D√©finition | Exemple |
|-------|------------|---------|
| **Exigence fonctionnelle** | Fonction que le syst√®me doit r√©aliser | "L'utilisateur doit pouvoir r√©initialiser son mot de passe" |
| **Exigence non fonctionnelle** | Contrainte ou qualit√© du syst√®me | "Le temps de r√©ponse doit √™tre < 2 secondes" |
| **User Story** | Description courte d'une fonctionnalit√© du point de vue utilisateur | "En tant que client, je veux pouvoir filtrer les produits par prix" |
| **Backlog** | Liste prioris√©e des fonctionnalit√©s √† d√©velopper | Ensemble des user stories en attente |
| **Sprint** | P√©riode de temps fixe pour d√©velopper un ensemble de fonctionnalit√©s | Sprint de 2 semaines |
| **Livrable** | Produit ou document r√©sultant d'une phase | Code source, documentation, rapport de tests |
| **Jalons (Milestones)** | Points de contr√¥le majeurs dans le projet | Fin de la conception, mise en production |
| **Stakeholder** | Partie prenante ayant un int√©r√™t dans le projet | Client, utilisateurs, direction, √©quipe |

### 1.1.4 M√©triques et indicateurs

Pour piloter efficacement un projet, plusieurs indicateurs sont essentiels:

**Indicateurs de progression:**
- **Avancement physique:** Pourcentage de t√¢ches termin√©es
- **V√©locit√©:** Quantit√© de travail r√©alis√©e par it√©ration (en Agile)
- **Burn-down chart:** Visualisation du travail restant

**Indicateurs de qualit√©:**
- **Densit√© de d√©fauts:** Nombre de bugs par 1000 lignes de code
- **Couverture de tests:** Pourcentage de code couvert par les tests
- **Dette technique:** Effort estim√© pour corriger les imperfections

**Indicateurs de co√ªt:**
- **Budget consomm√©:** D√©penses r√©elles vs pr√©vues
- **Co√ªt par fonctionnalit√©:** Budget / nombre de fonctionnalit√©s
- **ROI (Return on Investment):** B√©n√©fices / Co√ªts

---

## 1.2 Cycle en V, mod√®le en spirale, et m√©thodes it√©ratives

### 1.2.1 Le mod√®le en cascade (Waterfall)

**Principe:** Approche s√©quentielle o√π chaque phase doit √™tre compl√©t√©e avant de passer √† la suivante.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Analyse       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Conception     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ D√©veloppement   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Tests       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  D√©ploiement    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Maintenance   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**‚úÖ Avantages:**
- Simple √† comprendre et √† g√©rer
- Documentation compl√®te et structur√©e
- Adapt√© aux projets avec exigences stables et bien d√©finies
- Facilite la planification et l'estimation

**‚ùå Inconv√©nients:**
- Rigide et peu flexible face aux changements
- Retour utilisateur tardif (en fin de projet)
- Risques d√©couverts tard dans le processus
- Pas adapt√© aux projets innovants ou exploratoires

**üéØ Cas d'usage typiques:**
- Projets r√©glementaires avec sp√©cifications fig√©es
- Syst√®mes critiques (a√©ronautique, m√©dical)
- Projets avec budget et d√©lai fixes
- Migration de syst√®mes existants bien document√©s

### 1.2.2 Le cycle en V

**Principe:** Extension du mod√®le en cascade int√©grant explicitement les phases de validation et v√©rification.

```
        Conception                    Validation
              
    Sp√©cifications  ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  Tests d'acceptation
         ‚îÇ                              ‚ñ≤
         ‚îÇ                              ‚îÇ
    Architecture    ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  Tests d'int√©gration
         ‚îÇ                              ‚ñ≤
         ‚îÇ                              ‚îÇ
 Conception d√©taill√©e ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí   Tests unitaires
         ‚îÇ                              ‚ñ≤
         ‚îÇ                              ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  Codage  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Caract√©ristiques cl√©s:**
- **Correspondance:** Chaque phase de conception a une phase de test correspondante
- **Tra√ßabilit√©:** Lien direct entre exigences et tests de validation
- **Documentation:** Forte emphase sur la documentation √† chaque niveau

**Phases descendantes (gauche):**
1. **Analyse des besoins** ‚Üí d√©finition des tests d'acceptation
2. **Sp√©cifications fonctionnelles** ‚Üí d√©finition des tests fonctionnels
3. **Conception architecturale** ‚Üí d√©finition des tests d'int√©gration
4. **Conception d√©taill√©e** ‚Üí d√©finition des tests unitaires
5. **Codage** (bas du V)

**Phases ascendantes (droite):**
1. **Tests unitaires** ‚Üê v√©rification de la conception d√©taill√©e
2. **Tests d'int√©gration** ‚Üê v√©rification de l'architecture
3. **Tests fonctionnels** ‚Üê validation des sp√©cifications
4. **Tests d'acceptation** ‚Üê validation des besoins

**‚úÖ Avantages:**
- Approche rigoureuse et syst√©matique
- Forte tra√ßabilit√© entre exigences et tests
- D√©tection pr√©coce des erreurs de conception
- Qualit√© √©lev√©e du produit final

**‚ùå Inconv√©nients:**
- Peu flexible face aux changements
- Co√ªt √©lev√© des modifications tardives
- N√©cessite des sp√©cifications tr√®s pr√©cises d√®s le d√©but
- D√©lai avant la premi√®re livraison

**üéØ Cas d'usage typiques:**
- Syst√®mes embarqu√©s
- Applications critiques (banque, sant√©, a√©ronautique)
- Projets √† forte exigence de tra√ßabilit√©
- D√©veloppement de syst√®mes avec certification

**Exemple concret: Syst√®me de gestion bancaire**

```
Phase 1: Analyse des besoins
‚îî‚îÄ Exigence: "Le syst√®me doit permettre les virements s√©curis√©s"
   ‚îî‚îÄ Test d'acceptation: Sc√©narios de virements avec v√©rifications

Phase 2: Sp√©cifications fonctionnelles
‚îî‚îÄ Fonction: Module de transaction avec authentification forte
   ‚îî‚îÄ Test fonctionnel: Validation du workflow complet

Phase 3: Architecture
‚îî‚îÄ Composant: Service de transaction + Base de donn√©es
   ‚îî‚îÄ Test d'int√©gration: Communication entre services

Phase 4: Conception d√©taill√©e
‚îî‚îÄ Classe: TransactionService avec m√©thode processTransfer()
   ‚îî‚îÄ Test unitaire: Test de la m√©thode processTransfer()
```

### 1.2.3 Le mod√®le en spirale

**Principe:** Approche it√©rative combinant d√©veloppement et gestion des risques, cr√©√© par Barry Boehm en 1988.

```
                  D√©terminer
                  objectifs
                      ‚îÇ
                      ‚ñº
    Planifier    ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫    √âvaluer
    prochaine                 risques
    it√©ration                     ‚îÇ
         ‚ñ≤                        ‚îÇ
         ‚îÇ                        ‚ñº
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   D√©velopper
                          et tester
```

**Les 4 quadrants de chaque it√©ration:**

1. **D√©finition des objectifs (Quadrant 1)**
   - Identifier les objectifs de l'it√©ration
   - D√©finir les alternatives possibles
   - Identifier les contraintes

2. **Analyse des risques (Quadrant 2)**
   - √âvaluer les alternatives
   - Identifier et r√©soudre les risques
   - Prototypage si n√©cessaire

3. **D√©veloppement et test (Quadrant 3)**
   - D√©velopper le produit
   - Valider par des tests
   - Int√©grer les retours

4. **Planification (Quadrant 4)**
   - √âvaluer les r√©sultats
   - Planifier la prochaine it√©ration
   - D√©cision de continuer ou arr√™ter

**‚úÖ Avantages:**
- Gestion proactive des risques
- Flexibilit√© et adaptabilit√©
- Validation continue avec les utilisateurs
- D√©tection pr√©coce des probl√®mes

**‚ùå Inconv√©nients:**
- Complexit√© de gestion
- N√©cessite une expertise en gestion des risques
- Peut √™tre co√ªteux
- Difficult√© d'estimation des co√ªts totaux

**üéØ Cas d'usage typiques:**
- Projets innovants avec risques techniques √©lev√©s
- Grands syst√®mes complexes
- Projets de R&D
- D√©veloppement de nouveaux produits

**Exemple d'it√©ration:**

```
It√©ration 1: Preuve de concept
‚îú‚îÄ Objectif: Valider la faisabilit√© technique
‚îú‚îÄ Risques: Compatibilit√© avec syst√®me existant
‚îú‚îÄ D√©veloppement: Prototype minimal
‚îî‚îÄ R√©sultat: Go/No-go pour la suite

It√©ration 2: Architecture de base
‚îú‚îÄ Objectif: Impl√©menter l'architecture principale
‚îú‚îÄ Risques: Performance insuffisante
‚îú‚îÄ D√©veloppement: Framework de base + tests de charge
‚îî‚îÄ R√©sultat: Architecture valid√©e

It√©ration 3: Fonctionnalit√©s principales
‚îú‚îÄ Objectif: D√©velopper les 3 fonctions critiques
‚îú‚îÄ Risques: Complexit√© d'int√©gration
‚îú‚îÄ D√©veloppement: Modules + tests d'int√©gration
‚îî‚îÄ R√©sultat: MVP fonctionnel
```

### 1.2.4 Les m√©thodes it√©ratives et incr√©mentales

**Principe:** D√©veloppement par cycles courts produisant des versions successives de plus en plus compl√®tes.

**Diff√©rence entre it√©ratif et incr√©mental:**

```
Incr√©mental: Construction progressive
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  A  ‚îÇ  ‚îÇ A+B ‚îÇ  ‚îÇA+B+C‚îÇ  ‚îÇABCD ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 V1.0     V1.1     V1.2     V1.3

It√©ratif: Raffinement successif
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ A‚ÇÅ  ‚îÇ  ‚îÇ A‚ÇÇ  ‚îÇ  ‚îÇ A‚ÇÉ  ‚îÇ  ‚îÇ A‚ÇÑ  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Version  Version  Version  Version
basique  am√©lior√©e optimale  finale
```

**Caract√©ristiques:**
- **Cycles courts:** 2-4 semaines g√©n√©ralement
- **Livrables fonctionnels:** Chaque it√©ration produit du code ex√©cutable
- **Feedback continu:** Validation r√©guli√®re avec les utilisateurs
- **Adaptation:** Ajustement du plan selon les retours

**Processus typique d'une it√©ration:**

```
1. Planification de l'it√©ration (1 jour)
   ‚îî‚îÄ S√©lection des user stories
   ‚îî‚îÄ D√©coupage en t√¢ches
   ‚îî‚îÄ Estimation

2. D√©veloppement (8-10 jours)
   ‚îî‚îÄ Conception
   ‚îî‚îÄ Codage
   ‚îî‚îÄ Tests unitaires
   ‚îî‚îÄ Revues de code

3. Int√©gration et tests (2-3 jours)
   ‚îî‚îÄ Tests d'int√©gration
   ‚îî‚îÄ Tests fonctionnels
   ‚îî‚îÄ Correction de bugs

4. D√©monstration et r√©trospective (1 jour)
   ‚îî‚îÄ Pr√©sentation aux stakeholders
   ‚îî‚îÄ Collecte de feedback
   ‚îî‚îÄ Am√©lioration du processus
```

**‚úÖ Avantages:**
- Retour rapide des utilisateurs
- R√©duction des risques
- Meilleure gestion du changement
- Visibilit√© continue sur l'avancement
- Motivation de l'√©quipe

**‚ùå Inconv√©nients:**
- N√©cessite une forte implication des utilisateurs
- Peut manquer de vision d'ensemble
- Risque d'architecture √©mergente non optimale
- N√©cessite une √©quipe mature

### 1.2.5 Comparaison des mod√®les

| Crit√®re | Cascade | Cycle en V | Spirale | It√©ratif |
|---------|---------|------------|---------|----------|
| **Flexibilit√©** | ‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Gestion des risques** | ‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Documentation** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Feedback utilisateur** | ‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Pr√©visibilit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Complexit√© de gestion** | ‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Adapt√© aux changements** | ‚≠ê | ‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |

**Crit√®res de choix:**

```
Choisir Cascade/V si:
‚úì Exigences claires et stables
‚úì Projet bien d√©fini et document√©
‚úì Domaine r√©glement√©
‚úì Faible tol√©rance aux changements

Choisir Spirale si:
‚úì Projet innovant et risqu√©
‚úì Budget flexible
‚úì Expertise en gestion des risques
‚úì Projet de grande envergure

Choisir It√©ratif si:
‚úì Exigences √©volutives
‚úì Feedback utilisateur important
‚úì Time-to-market critique
‚úì √âquipe agile et autonome
```

---

## 1.3 Gestion des exigences et cahier des charges

### 1.3.1 Qu'est-ce qu'une exigence?

**D√©finition:**
> Une exigence est une caract√©ristique, fonction ou contrainte qu'un syst√®me doit satisfaire pour r√©pondre aux besoins de ses parties prenantes.

**Propri√©t√©s d'une bonne exigence (SMART):**
- **Sp√©cifique:** D√©crit pr√©cis√©ment ce qui est attendu
- **Mesurable:** Permet la v√©rification objective
- **Atteignable:** R√©alisable techniquement et √©conomiquement
- **R√©aliste:** Coh√©rent avec les contraintes du projet
- **Temporel:** Situ√© dans le temps (d√©lai, priorit√©)

### 1.3.2 Types d'exigences

#### Exigences fonctionnelles (Functional Requirements)

D√©crivent **ce que le syst√®me doit faire** - les fonctionnalit√©s et services.

**Exemples:**
```
EX-FUNC-001: L'utilisateur doit pouvoir cr√©er un compte avec email et mot de passe
EX-FUNC-002: Le syst√®me doit envoyer un email de confirmation apr√®s l'inscription
EX-FUNC-003: L'utilisateur doit pouvoir rechercher des produits par cat√©gorie
EX-FUNC-004: Le syst√®me doit calculer automatiquement le prix total avec TVA
```

**Structure recommand√©e:**
```
ID: [Identifiant unique]
Titre: [Nom court de l'exigence]
Description: [Description d√©taill√©e]
Priorit√©: [Critique/Haute/Moyenne/Basse]
Acteur: [Qui utilise cette fonction]
Pr√©conditions: [Conditions pr√©alables]
Postconditions: [R√©sultat attendu]
Cas d'exception: [Situations d'erreur]
```

#### Exigences non fonctionnelles (Non-Functional Requirements)

D√©crivent **comment le syst√®me doit fonctionner** - les qualit√©s et contraintes.

**Cat√©gories principales:**

**1. Performance**
```
EX-PERF-001: Le temps de r√©ponse des API doit √™tre < 200ms pour 95% des requ√™tes
EX-PERF-002: Le syst√®me doit supporter 10 000 utilisateurs simultan√©s
EX-PERF-003: Le d√©marrage de l'application doit prendre moins de 3 secondes
```

**2. S√©curit√©**
```
EX-SEC-001: Les mots de passe doivent √™tre hash√©s avec bcrypt (min. 12 rounds)
EX-SEC-002: Les communications doivent utiliser TLS 1.3 minimum
EX-SEC-003: Le syst√®me doit impl√©menter l'authentification √† deux facteurs
```

**3. Disponibilit√© et fiabilit√©**
```
EX-DISP-001: Le syst√®me doit avoir une disponibilit√© de 99.9% (SLA)
EX-DISP-002: Le temps de r√©cup√©ration apr√®s panne doit √™tre < 15 minutes
EX-FIAB-001: Le taux d'√©chec des transactions doit √™tre < 0.1%
```

**4. Utilisabilit√©**
```
EX-UTIL-001: L'interface doit √™tre responsive (mobile, tablet, desktop)
EX-UTIL-002: Le syst√®me doit supporter les lecteurs d'√©cran (WCAG 2.1 niveau AA)
EX-UTIL-003: La navigation principale doit √™tre accessible en < 3 clics
```

**5. Maintenabilit√©**
```
EX-MAINT-001: Le code doit avoir une couverture de tests > 80%
EX-MAINT-002: La documentation technique doit √™tre √† jour
EX-MAINT-003: Le code doit respecter les standards ESLint/SonarQube
```

**6. Compatibilit√©**
```
EX-COMP-001: L'application doit fonctionner sur Chrome, Firefox, Safari, Edge
EX-COMP-002: L'API doit √™tre compatible avec les versions mobiles iOS 14+ et Android 10+
EX-COMP-003: Le syst√®me doit s'int√©grer avec Active Directory
```

**7. Scalabilit√©**
```
EX-SCAL-001: L'architecture doit permettre un scaling horizontal
EX-SCAL-002: La base de donn√©es doit supporter un partitionnement (sharding)
```

**8. L√©gales et r√©glementaires**
```
EX-LEG-001: Le syst√®me doit √™tre conforme au RGPD
EX-LEG-002: Les logs d'audit doivent √™tre conserv√©s 7 ans
EX-LEG-003: Le consentement utilisateur doit √™tre explicite et r√©vocable
```

### 1.3.3 Collecte des exigences

**Techniques de collecte:**

#### 1. Entretiens (Interviews)
**Approche:** Discussion en t√™te-√†-t√™te avec les parties prenantes

```
Pr√©paration:
‚îú‚îÄ Identifier les stakeholders cl√©s
‚îú‚îÄ Pr√©parer les questions
‚îú‚îÄ D√©finir les objectifs de l'entretien
‚îî‚îÄ Pr√©voir 60-90 minutes

Conduite:
‚îú‚îÄ Questions ouvertes: "Comment g√©rez-vous actuellement...?"
‚îú‚îÄ Questions ferm√©es: "Avez-vous besoin de...?"
‚îú‚îÄ √âcoute active et prise de notes
‚îî‚îÄ Demande d'exemples concrets

Synth√®se:
‚îú‚îÄ R√©daction du compte-rendu
‚îú‚îÄ Validation avec l'interview√©
‚îî‚îÄ Extraction des exigences
```

**‚úÖ Avantages:** Informations d√©taill√©es, clarification imm√©diate  
**‚ùå Inconv√©nients:** Chronophage, d√©pend de la qualit√© de communication

#### 2. Ateliers (Workshops)
**Approche:** Sessions collaboratives avec plusieurs stakeholders

```
Organisation:
‚îú‚îÄ 5-10 participants
‚îú‚îÄ Dur√©e: 2-4 heures
‚îú‚îÄ Facilitateur + scribe
‚îî‚îÄ Salle avec tableau blanc/paperboard

Techniques:
‚îú‚îÄ Brainstorming
‚îú‚îÄ Cartes mentales (mind mapping)
‚îú‚îÄ Priorisation (MoSCoW, Dot Voting)
‚îî‚îÄ Story mapping

R√©sultat:
‚îú‚îÄ Vision partag√©e
‚îú‚îÄ Liste d'exigences prioris√©es
‚îî‚îÄ Consensus sur les priorit√©s
```

**‚úÖ Avantages:** Consensus rapide, cr√©ativit√© collective  
**‚ùå Inconv√©nients:** Peut √™tre domin√© par certaines voix, n√©cessite bonne animation

#### 3. Questionnaires
**Approche:** Collecte structur√©e d'informations aupr√®s d'un large public

```
Conception:
‚îú‚îÄ Questions claires et concises
‚îú‚îÄ Mix de questions ferm√©es et ouvertes
‚îú‚îÄ 10-20 questions maximum
‚îî‚îÄ Temps estim√©: 10-15 minutes

Distribution:
‚îú‚îÄ Email, formulaire en ligne (Google Forms, Typeform)
‚îú‚îÄ Population cible clairement identifi√©e
‚îî‚îÄ Relances si n√©cessaire

Analyse:
‚îú‚îÄ Statistiques descriptives
‚îú‚îÄ Identification des tendances
‚îî‚îÄ Extraction des exigences r√©currentes
```

**‚úÖ Avantages:** Nombreux retours, quantifiable  
**‚ùå Inconv√©nients:** Pas de nuances, taux de r√©ponse variable

#### 4. Observation
**Approche:** Observer les utilisateurs dans leur environnement de travail

```
Pr√©paration:
‚îú‚îÄ D√©finir les objectifs d'observation
‚îú‚îÄ Planifier les sessions
‚îú‚îÄ Informer et obtenir le consentement
‚îî‚îÄ Pr√©parer une grille d'observation

Observation:
‚îú‚îÄ Noter les actions effectu√©es
‚îú‚îÄ Identifier les difficult√©s
‚îú‚îÄ Rep√©rer les workarounds
‚îú‚îÄ Mesurer les temps
‚îî‚îÄ Poser des questions de clarification

Analyse:
‚îú‚îÄ Identifier les processus inefficaces
‚îú‚îÄ D√©tecter les besoins non exprim√©s
‚îî‚îÄ Formuler des exigences d'am√©lioration
```

**‚úÖ Avantages:** D√©tecte les besoins implicites, objectif  
**‚ùå Inconv√©nients:** Effet Hawthorne (comportement modifi√© par observation), chronophage

#### 5. Analyse de documents
**Approche:** √âtudier la documentation existante

```
Sources:
‚îú‚îÄ Proc√©dures op√©rationnelles
‚îú‚îÄ Manuels utilisateurs actuels
‚îú‚îÄ Rapports et statistiques
‚îú‚îÄ R√©glementation et normes
‚îú‚îÄ Contrats et SLA
‚îî‚îÄ Documentation technique existante

Analyse:
‚îú‚îÄ Identifier les fonctionnalit√©s actuelles
‚îú‚îÄ Rep√©rer les contraintes l√©gales
‚îú‚îÄ Comprendre les processus m√©tier
‚îî‚îÄ Extraire les exigences de compatibilit√©
```

**‚úÖ Avantages:** Non intrusif, contextuel  
**‚ùå Inconv√©nients:** Documentation parfois obsol√®te ou incompl√®te

#### 6. Prototypage
**Approche:** Cr√©er une maquette pour faire r√©agir les utilisateurs

```
Types de prototypes:
‚îú‚îÄ Wireframes: Structure basique
‚îú‚îÄ Mockups: Design visuel
‚îú‚îÄ Prototypes interactifs: Simulation des interactions
‚îî‚îÄ POC (Proof of Concept): Validation technique

Processus:
1. Cr√©er le prototype (basse/haute fid√©lit√©)
2. Pr√©senter aux utilisateurs
3. Recueillir les retours
4. It√©rer sur le prototype
5. Formaliser les exigences valid√©es
```

**‚úÖ Avantages:** Concret, retour visuel imm√©diat  
**‚ùå Inconv√©nients:** Risque de focus sur l'UI plut√¥t que les fonctionnalit√©s

### 1.3.4 Le cahier des charges (Sp√©cification des Exigences Logicielles - SRS)

**D√©finition:**
> Le cahier des charges (ou SRS - Software Requirements Specification) est le document formel qui d√©crit de mani√®re compl√®te et non ambigu√´ ce que le syst√®me doit faire.

**Structure type d'un SRS selon IEEE 830:**

```
1. INTRODUCTION
   1.1 Objectif du document
   1.2 Port√©e du syst√®me
   1.3 D√©finitions, acronymes et abr√©viations
   1.4 R√©f√©rences
   1.5 Vue d'ensemble du document

2. DESCRIPTION G√âN√âRALE
   2.1 Perspective du produit
       ‚îú‚îÄ Interfaces syst√®mes
       ‚îú‚îÄ Interfaces utilisateurs
       ‚îú‚îÄ Interfaces mat√©rielles
       ‚îî‚îÄ Interfaces logicielles
   2.2 Fonctions du produit (vue d'ensemble)
   2.3 Caract√©ristiques des utilisateurs
   2.4 Contraintes g√©n√©rales
   2.5 Hypoth√®ses et d√©pendances

3. EXIGENCES SP√âCIFIQUES
   3.1 Exigences fonctionnelles
       ‚îú‚îÄ Cas d'utilisation
       ‚îú‚îÄ Diagrammes de s√©quence
       ‚îî‚îÄ Description d√©taill√©e de chaque fonction
   3.2 Exigences non fonctionnelles
       ‚îú‚îÄ Performance
       ‚îú‚îÄ S√©curit√©
       ‚îú‚îÄ Fiabilit√©
       ‚îú‚îÄ Disponibilit√©
       ‚îî‚îÄ Maintenabilit√©
   3.3 Exigences d'interface
       ‚îú‚îÄ Interface utilisateur
       ‚îú‚îÄ Interface logicielle (API)
       ‚îî‚îÄ Interface mat√©rielle
   3.4 Exigences de donn√©es
       ‚îú‚îÄ Mod√®le de donn√©es
       ‚îî‚îÄ R√®gles de gestion

4. MOD√àLES UML
   4.1 Diagrammes de cas d'utilisation
   4.2 Diagrammes de classes (conceptuel)
   4.3 Diagrammes d'activit√©
   4.4 Diagrammes d'√©tats

5. ANNEXES
   5.1 Glossaire
   5.2 Mod√®les de documents
   5.3 R√©f√©rences techniques
```

**Exemple concret - Extrait d'un SRS pour un syst√®me e-commerce:**

```markdown
3.1.2 Gestion du panier d'achat

EX-FUNC-012: Ajout d'un produit au panier
‚îú‚îÄ Priorit√©: Critique
‚îú‚îÄ Acteur: Client (authentifi√© ou anonyme)
‚îú‚îÄ Pr√©conditions: 
‚îÇ   ‚îî‚îÄ Le produit existe et est disponible en stock
‚îú‚îÄ Description:
‚îÇ   Le client peut ajouter un produit √† son panier en sp√©cifiant la quantit√©.
‚îÇ   Le syst√®me v√©rifie la disponibilit√© et met √† jour le panier.
‚îú‚îÄ Sc√©nario nominal:
‚îÇ   1. Le client visualise la fiche produit
‚îÇ   2. Le client s√©lectionne la quantit√© souhait√©e
‚îÇ   3. Le client clique sur "Ajouter au panier"
‚îÇ   4. Le syst√®me v√©rifie la disponibilit√© du stock
‚îÇ   5. Le syst√®me ajoute le produit au panier
‚îÇ   6. Le syst√®me affiche une confirmation
‚îÇ   7. Le syst√®me met √† jour le compteur du panier
‚îú‚îÄ Sc√©narios alternatifs:
‚îÇ   A1. Stock insuffisant
‚îÇ       4a. Le syst√®me affiche la quantit√© maximum disponible
‚îÇ       4b. Le syst√®me propose d'ajuster la quantit√©
‚îÇ   A2. Client non authentifi√©
‚îÇ       5a. Le panier est stock√© en session locale
‚îÇ       5b. √Ä la connexion, fusion avec le panier serveur
‚îú‚îÄ Postconditions:
‚îÇ   ‚îî‚îÄ Le produit est dans le panier avec la quantit√© sp√©cifi√©e
‚îú‚îÄ R√®gles m√©tier:
‚îÇ   ‚îú‚îÄ RG-001: Maximum 10 unit√©s par produit
‚îÇ   ‚îú‚îÄ RG-002: V√©rification du stock en temps r√©el
‚îÇ   ‚îî‚îÄ RG-003: Panier anonyme conserv√© 24h
‚îî‚îÄ Crit√®res d'acceptation:
    ‚îú‚îÄ Le produit appara√Æt dans le panier
    ‚îú‚îÄ La quantit√© est correcte
    ‚îú‚îÄ Le prix total est mis √† jour
    ‚îî‚îÄ Le message de confirmation s'affiche
```

**Bonnes pratiques de r√©daction:**

‚úÖ **Utiliser un langage clair et pr√©cis**
```
‚ùå "Le syst√®me doit √™tre rapide"
‚úÖ "Le syst√®me doit afficher la page d'accueil en moins de 2 secondes"
```

‚úÖ **Une exigence = une fonctionnalit√©**
```
‚ùå "Le syst√®me doit permettre la connexion et l'inscription"
‚úÖ "EX-001: Le syst√®me doit permettre la connexion"
   "EX-002: Le syst√®me doit permettre l'inscription"
```

‚úÖ **√âviter les termes ambigus**
```
‚ùå "adapt√©", "flexible", "user-friendly", "robuste"
‚úÖ "conforme √† WCAG 2.1", "extensible via plugins", "disponible √† 99.9%"
```

‚úÖ **Tra√ßabilit√©**
```
Chaque exigence doit avoir:
‚îú‚îÄ Identifiant unique
‚îú‚îÄ Origine (qui l'a demand√©e)
‚îú‚îÄ Justification (pourquoi)
‚îî‚îÄ Crit√®res de validation (comment tester)
```

### 1.3.5 Gestion et tra√ßabilit√© des exigences

**Matrice de tra√ßabilit√©:**

| ID Exigence | Origine | Cas d'utilisation | Composant | Tests | Statut |
|-------------|---------|-------------------|-----------|-------|---------|
| EX-FUNC-001 | Client | UC-001 | UserService | UT-001, IT-005 | ‚úÖ Valid√© |
| EX-FUNC-002 | RGPD | UC-002, UC-003 | DataService | UT-010, IT-008 | üîÑ En cours |
| EX-PERF-001 | Direction | - | Cache Layer | PT-001 | ‚è≥ Planifi√© |

**Outils de gestion des exigences:**
- **Jira + Confluence:** Gestion agile avec tra√ßabilit√©
- **Azure DevOps:** Int√©gration compl√®te (exigences ‚Üí code ‚Üí tests)
- **IBM DOORS:** Gestion avanc√©e pour projets critiques
- **Caliber:** Tra√ßabilit√© et gestion des changements
- **Tableau Excel:** Solution simple pour petits projets

**Gestion des changements d'exigences:**

```
Processus de change management:

1. Demande de changement
   ‚îú‚îÄ Formulaire standardis√©
   ‚îú‚îÄ Justification
   ‚îî‚îÄ Impact estim√©

2. Analyse d'impact
   ‚îú‚îÄ Impact fonctionnel
   ‚îú‚îÄ Impact technique
   ‚îú‚îÄ Impact planning/co√ªt
   ‚îî‚îÄ Impact qualit√©

3. D√©cision
   ‚îú‚îÄ Comit√© de changement
   ‚îú‚îÄ Approbation ou rejet
   ‚îî‚îÄ Priorisation

4. Impl√©mentation
   ‚îú‚îÄ Mise √† jour de la documentation
   ‚îú‚îÄ Communication aux √©quipes
   ‚îú‚îÄ D√©veloppement
   ‚îî‚îÄ Validation

5. Tra√ßabilit√©
   ‚îú‚îÄ Historique des modifications
   ‚îú‚îÄ Versions du SRS
   ‚îî‚îÄ Justifications
```

---

## 1.4 Lien entre analyse m√©tier et conception technique

### 1.4.1 De la vision m√©tier √† la r√©alit√© technique

**Le pont entre deux mondes:**

```
Monde M√©tier                    Monde Technique
(Langage business)             (Langage IT)

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Besoins    ‚îÇ              ‚îÇ Architecture ‚îÇ
‚îÇ   m√©tier     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  technique   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                             ‚îÇ
       ‚îÇ Traduction                  ‚îÇ
       ‚ñº                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Processus   ‚îÇ              ‚îÇ  Composants  ‚îÇ
‚îÇ   m√©tier     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  logiciels   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                             ‚îÇ
       ‚îÇ Formalisation               ‚îÇ
       ‚ñº                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ R√®gles de    ‚îÇ              ‚îÇ  Code source ‚îÇ
‚îÇ  gestion     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  et donn√©es  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**R√¥le du d√©veloppeur de syst√®mes:**
- üéß **√âcouter** et comprendre le langage m√©tier
- üîÑ **Traduire** les besoins en sp√©cifications techniques
- üèóÔ∏è **Concevoir** une architecture adapt√©e
- ‚öñÔ∏è **Arbitrer** entre contraintes m√©tier et faisabilit√© technique
- üîó **Assurer** la coh√©rence entre vision m√©tier et impl√©mentation

### 1.4.2 Techniques de mod√©lisation orient√©e m√©tier

#### Domain-Driven Design (DDD)

**Principe:** Placer le domaine m√©tier au c≈ìur de la conception logicielle.

**Concepts cl√©s:**

**1. Ubiquitous Language (Langage omnipr√©sent)**
```
Cr√©er un vocabulaire commun entre m√©tier et technique:

M√©tier dit:              Code contient:
"Client"          ‚Üí      class Customer
"Commande"        ‚Üí      class Order
"Valider"         ‚Üí      method validate()
"En attente"      ‚Üí      enum Status.PENDING
```

**2. Bounded Context (Contexte d√©limit√©)**
```
Diviser le syst√®me en contextes avec leur propre mod√®le:

Contexte Ventes:
‚îú‚îÄ Client (avec historique d'achats)
‚îú‚îÄ Commande
‚îî‚îÄ Catalogue produits

Contexte Livraison:
‚îú‚îÄ Destinataire (adresse de livraison)
‚îú‚îÄ Colis
‚îî‚îÄ Statut de livraison

Le m√™me concept ("Client") peut avoir des significations diff√©rentes
dans chaque contexte !
```

**3. Entities, Value Objects, Aggregates**
```java
// Entity: Objet avec identit√© unique
public class Order {
    private OrderId id;  // Identit√©
    private Customer customer;
    private List<OrderLine> lines;
    private OrderStatus status;
    
    // Logique m√©tier encapsul√©e
    public void addLine(Product product, int quantity) {
        if (status != OrderStatus.DRAFT) {
            throw new OrderClosedException();
        }
        lines.add(new OrderLine(product, quantity));
    }
}

// Value Object: Objet sans identit√©, d√©fini par ses attributs
public class Money {
    private final BigDecimal amount;
    private final Currency currency;
    
    // Immutable
    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new CurrencyMismatchException();
        }
        return new Money(this.amount.add(other.amount), this.currency);
    }
}

// Aggregate: Groupe d'objets trait√©s comme une unit√©
public class Order {  // Aggregate Root
    private List<OrderLine> lines;  // Part of the aggregate
    
    // Invariants m√©tier garantis
    public void removeAllLinesForProduct(ProductId productId) {
        lines.removeIf(line -> line.getProductId().equals(productId));
        recalculateTotal();  // Maintien de la coh√©rence
    }
}
```

**4. Services de domaine**
```java
// Logique m√©tier qui ne rel√®ve pas d'une entit√© sp√©cifique
public class PricingService {
    public Money calculateOrderTotal(Order order, Customer customer) {
        Money subtotal = order.getSubtotal();
        Money discount = calculateDiscount(customer, subtotal);
        Money tax = calculateTax(subtotal.subtract(discount));
        return subtotal.subtract(discount).add(tax);
    }
    
    private Money calculateDiscount(Customer customer, Money amount) {
        // R√®gles m√©tier complexes de remise
        if (customer.isVIP()) {
            return amount.multiply(0.10);
        } else if (customer.hasLoyaltyCard()) {
            return amount.multiply(0.05);
        }
        return Money.zero(amount.getCurrency());
    }
}
```

#### Event Storming

**Principe:** Atelier collaboratif pour mod√©liser les processus m√©tier via les √©v√©nements.

**Processus:**
```
1. Identifier les Domain Events (√©v√©nements m√©tier)
   Orange: "CommandePass√©e", "PaiementRe√ßu", "ComandeExp√©di√©e"

2. Ordonner chronologiquement
   Timeline: √©v√©nements dans l'ordre temporel

3. Identifier les Commands (actions)
   Bleu: "PasserCommande", "PayerCommande", "Exp√©dierCommande"

4. Identifier les Aggregates
   Jaune: "Commande", "Paiement", "Exp√©dition"

5. Identifier les Policies (r√®gles)
   Violet: "Quand PaiementRe√ßu, alors notifier entrep√¥t"

6. Identifier les Read Models (vues)
   Vert: "Liste des commandes", "Tableau de bord"
```

**Exemple visuel:**
```
[PasserCommande] ‚Üí [CommandePass√©e] ‚Üí [V√©rifier Stock]
                         ‚Üì
                   [Commande] (Aggregate)
                         ‚Üì
              [Stock insuffisant] ?
                   ‚Üô        ‚Üò
               [OUI]        [NON]
                 ‚Üì            ‚Üì
    [CommandeAnnul√©e]  [CommandeConfirm√©e]
                              ‚Üì
                       [Traiter Paiement]
                              ‚Üì
                       [PaiementRe√ßu]
                              ‚Üì
                    Policy: Notifier entrep√¥t
                              ‚Üì
                       [Exp√©dierCommande]
```

**‚úÖ Avantages:**
- Collaboration m√©tier/IT
- Compr√©hension partag√©e
- Identification des processus complexes
- Base pour architecture √©v√©nementielle

### 1.4.3 Du mod√®le m√©tier au code

**Exemple complet: Syst√®me de gestion de biblioth√®que**

#### √âtape 1: Analyse m√©tier

**Processus m√©tier identifi√©:**
```
Un adh√©rent peut emprunter jusqu'√† 5 livres simultan√©ment.
La dur√©e d'emprunt est de 21 jours.
Si le livre n'est pas rendu √† temps, des frais de retard sont appliqu√©s.
Un adh√©rent avec des frais impay√©s ne peut pas emprunter.
```

#### √âtape 2: Mod√©lisation (UML Domaine)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Adh√©rent     ‚îÇ         ‚îÇ      Livre      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - id            ‚îÇ         ‚îÇ - id            ‚îÇ
‚îÇ - nom           ‚îÇ         ‚îÇ - ISBN          ‚îÇ
‚îÇ - email         ‚îÇ         ‚îÇ - titre         ‚îÇ
‚îÇ - fraisImpay√©s  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ - auteur        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    0..* ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + emprunter()   ‚îÇ    1..* ‚îÇ + estDisponible()‚îÇ
‚îÇ + rendre()      ‚îÇ         ‚îÇ                 ‚îÇ
‚îÇ + peutEmprunter()‚îÇ        ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚ñ≥                           ‚ñ≥
         ‚îÇ                           ‚îÇ
         ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ    Emprunt      ‚îÇ‚îÄ‚îÄ‚îÄ‚îò
              ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
              ‚îÇ - id            ‚îÇ
              ‚îÇ - dateEmprunt   ‚îÇ
              ‚îÇ - dateRetourPr√©vue‚îÇ
              ‚îÇ - dateRetourEffective‚îÇ
              ‚îÇ - statut        ‚îÇ
              ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
              ‚îÇ + calculerFraisRetard()‚îÇ
              ‚îÇ + estEnRetard() ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### √âtape 3: R√®gles m√©tier formalis√©es

```
RG-001: Limite d'emprunts simultan√©s
  QUAND Adh√©rent.empruntsActifs.count() >= 5
  ALORS Refuser nouvel emprunt

RG-002: Dur√©e d'emprunt
  Emprunt.dateRetourPr√©vue = Emprunt.dateEmprunt + 21 jours

RG-003: Frais de retard
  QUAND dateActuelle > Emprunt.dateRetourPr√©vue
  ALORS frais = (dateActuelle - dateRetourPr√©vue) * 0.50 CHF/jour

RG-004: Blocage pour impay√©s
  QUAND Adh√©rent.fraisImpay√©s > 0
  ALORS Adh√©rent.peutEmprunter() = false

RG-005: Disponibilit√©
  Livre.estDisponible() = true
  SI ET SEULEMENT SI aucun Emprunt actif pour ce livre
```

#### √âtape 4: Impl√©mentation technique

```java
// Entity: Adh√©rent
@Entity
public class Adherent {
    @Id
    private Long id;
    
    private String nom;
    private String email;
    
    @Column(name = "frais_impayes")
    private BigDecimal fraisImpayes = BigDecimal.ZERO;
    
    @OneToMany(mappedBy = "adherent")
    private List<Emprunt> emprunts = new ArrayList<>();
    
    // Logique m√©tier: RG-004
    public boolean peutEmprunter() {
        return fraisImpayes.compareTo(BigDecimal.ZERO) == 0;
    }
    
    // Logique m√©tier: RG-001
    public int nombreEmpruntsActifs() {
        return (int) emprunts.stream()
            .filter(Emprunt::estActif)
            .count();
    }
    
    // Logique m√©tier: Emprunter un livre
    public Emprunt emprunterLivre(Livre livre) {
        // Validation RG-004
        if (!peutEmprunter()) {
            throw new EmpruntRefuseException(
                "Impossible d'emprunter avec des frais impay√©s"
            );
        }
        
        // Validation RG-001
        if (nombreEmpruntsActifs() >= 5) {
            throw new EmpruntRefuseException(
                "Limite de 5 emprunts simultan√©s atteinte"
            );
        }
        
        // Validation disponibilit√© livre
        if (!livre.estDisponible()) {
            throw new LivreIndisponibleException(
                "Le livre n'est pas disponible"
            );
        }
        
        // Cr√©ation de l'emprunt - RG-002
        Emprunt emprunt = new Emprunt(this, livre);
        emprunts.add(emprunt);
        
        return emprunt;
    }
}

// Entity: Emprunt
@Entity
public class Emprunt {
    @Id
    private Long id;
    
    @ManyToOne
    private Adherent adherent;
    
    @ManyToOne
    private Livre livre;
    
    private LocalDate dateEmprunt;
    private LocalDate dateRetourPrevue;
    private LocalDate dateRetourEffective;
    
    @Enumerated(EnumType.STRING)
    private StatutEmprunt statut;
    
    // Constructeur - RG-002
    public Emprunt(Adherent adherent, Livre livre) {
        this.adherent = adherent;
        this.livre = livre;
        this.dateEmprunt = LocalDate.now();
        this.dateRetourPrevue = dateEmprunt.plusDays(21);  // RG-002
        this.statut = StatutEmprunt.ACTIF;
    }
    
    public boolean estActif() {
        return statut == StatutEmprunt.ACTIF;
    }
    
    // Logique m√©tier: RG-003
    public boolean estEnRetard() {
        return estActif() && LocalDate.now().isAfter(dateRetourPrevue);
    }
    
    // Logique m√©tier: RG-003
    public BigDecimal calculerFraisRetard() {
        if (!estEnRetard()) {
            return BigDecimal.ZERO;
        }
        
        long joursRetard = ChronoUnit.DAYS.between(
            dateRetourPrevue, 
            LocalDate.now()
        );
        
        return BigDecimal.valueOf(joursRetard)
            .multiply(new BigDecimal("0.50"));  // 0.50 CHF/jour
    }
    
    // Retour du livre
    public void retourner() {
        this.dateRetourEffective = LocalDate.now();
        this.statut = StatutEmprunt.TERMINE;
        
        // Calcul et ajout des frais de retard
        BigDecimal frais = calculerFraisRetard();
        if (frais.compareTo(BigDecimal.ZERO) > 0) {
            adherent.ajouterFraisImpayes(frais);
        }
    }
}

// Entity: Livre
@Entity
public class Livre {
    @Id
    private Long id;
    
    private String ISBN;
    private String titre;
    private String auteur;
    
    @OneToMany(mappedBy = "livre")
    private List<Emprunt> emprunts = new ArrayList<>();
    
    // Logique m√©tier: RG-005
    public boolean estDisponible() {
        return emprunts.stream()
            .noneMatch(Emprunt::estActif);
    }
}

// Service m√©tier
@Service
public class BibliothequeService {
    @Autowired
    private AdherentRepository adherentRepository;
    
    @Autowired
    private LivreRepository livreRepository;
    
    @Autowired
    private EmpruntRepository empruntRepository;
    
    @Transactional
    public EmpruntDTO emprunterLivre(Long adherentId, Long livreId) {
        Adherent adherent = adherentRepository.findById(adherentId)
            .orElseThrow(() -> new AdherentNotFoundException(adherentId));
        
        Livre livre = livreRepository.findById(livreId)
            .orElseThrow(() -> new LivreNotFoundException(livreId));
        
        // La logique m√©tier est dans le domaine !
        Emprunt emprunt = adherent.emprunterLivre(livre);
        
        empruntRepository.save(emprunt);
        
        return EmpruntMapper.toDTO(emprunt);
    }
    
    @Transactional
    public void retournerLivre(Long empruntId) {
        Emprunt emprunt = empruntRepository.findById(empruntId)
            .orElseThrow(() -> new EmpruntNotFoundException(empruntId));
        
        emprunt.retourner();
        
        empruntRepository.save(emprunt);
    }
}
```

**Points cl√©s de la traduction m√©tier ‚Üí technique:**

‚úÖ **Les r√®gles m√©tier sont dans le mod√®le de domaine** (pas dans les services)
‚úÖ **Le vocabulaire m√©tier est pr√©serv√©** (Adh√©rent, Emprunt, pas User, Borrow)
‚úÖ **Les contraintes sont valid√©es au plus t√¥t** (dans les m√©thodes m√©tier)
‚úÖ **Le code est testable** (logique isol√©e, pas de d√©pendances)
‚úÖ **La coh√©rence est garantie** (via les invariants de l'Aggregate)

### 1.4.4 Collaboration entre analystes m√©tier et d√©veloppeurs

**Ateliers de sp√©cification par l'exemple (Specification by Example)**

```
Sc√©nario: Emprunter un livre avec frais impay√©s

√âTANT DONN√â:
  - Un adh√©rent "Jean Dupont" avec 5 CHF de frais impay√©s
  - Un livre "Clean Code" disponible

QUAND:
  - Jean Dupont tente d'emprunter "Clean Code"

ALORS:
  - L'emprunt est refus√©
  - Un message d'erreur indique: "Impossible d'emprunter avec des frais impay√©s"
  - Le livre reste disponible
```

**Avantages:**
- Exemples concrets et testables
- Compr√©hension commune
- Base pour tests d'acceptation automatis√©s (Cucumber, SpecFlow)

**Processus collaboratif:**

```
1. Atelier d'exemple (3 Amigos)
   ‚îú‚îÄ Product Owner (m√©tier)
   ‚îú‚îÄ D√©veloppeur (technique)
   ‚îî‚îÄ Testeur (qualit√©)
   
2. Identification des sc√©narios
   ‚îú‚îÄ Happy path (cas nominal)
   ‚îú‚îÄ Cas d'erreur
   ‚îî‚îÄ Cas limites

3. Formalisation en Gherkin
   Given/When/Then

4. Impl√©mentation
   ‚îú‚îÄ Tests automatis√©s
   ‚îî‚îÄ Code de production

5. Validation
   ‚îú‚îÄ D√©mo au m√©tier
   ‚îî‚îÄ Ajustements si n√©cessaire
```

---

## üìù R√©sum√© du chapitre

### Points cl√©s √† retenir

‚úÖ Le **cycle de vie logiciel** structure le d√©veloppement de la conception √† la maintenance

‚úÖ Diff√©rents **mod√®les** existent: Cascade, Cycle en V (rigides), Spirale, It√©ratif (flexibles)

‚úÖ Le choix du mod√®le d√©pend du **contexte**: stabilit√© des exigences, risques, contraintes

‚úÖ Les **exigences** (fonctionnelles et non fonctionnelles) doivent √™tre claires, mesurables, tra√ßables

‚úÖ Le **cahier des charges** (SRS) formalise les exigences et sert de contrat

‚úÖ Le **Domain-Driven Design** met le m√©tier au c≈ìur de la conception technique

‚úÖ La **collaboration** m√©tier-IT est essentielle pour un produit r√©ussi

### Comp√©tences acquises

Apr√®s ce chapitre, vous devez √™tre capable de:

- ‚úÖ Expliquer les diff√©rentes phases d'un projet logiciel
- ‚úÖ Choisir un mod√®le de cycle de vie adapt√© au contexte
- ‚úÖ Collecter et formaliser des exigences
- ‚úÖ R√©diger un cahier des charges structur√©
- ‚úÖ Traduire des besoins m√©tier en conception technique
- ‚úÖ Appliquer les principes du Domain-Driven Design
- ‚úÖ Assurer la tra√ßabilit√© des exigences

---

## üí° Exercices pratiques

### Exercice 1: Choix du cycle de vie

Pour chacun des projets suivants, justifiez le choix du mod√®le de cycle de vie:

1. D√©veloppement d'un logiciel de pilotage d'avion
2. Application mobile de r√©seau social (startup)
3. Migration d'un syst√®me bancaire legacy vers le cloud
4. D√©veloppement d'un POC pour une technologie blockchain

<details>
<summary>üí° Solution</summary>

1. **Cycle en V**: Syst√®me critique, exigences r√©glementaires strictes, besoin de tra√ßabilit√© maximale
2. **It√©ratif/Agile**: Exigences √©volutives, feedback utilisateur essentiel, time-to-market
3. **Mod√®le en spirale**: Risques techniques √©lev√©s, besoin de validation progressive
4. **Prototypage rapide**: Exploration technologique, incertitudes, validation de concept
</details>

### Exercice 2: R√©daction d'exigences

Transformez les demandes floues suivantes en exigences SMART:

1. "L'application doit √™tre rapide"
2. "Le syst√®me doit √™tre s√©curis√©"
3. "L'interface doit √™tre intuitive"

<details>
<summary>üí° Solution</summary>

1. **EX-PERF-001**: Le temps de chargement de la page d'accueil doit √™tre inf√©rieur √† 2 secondes pour 95% des utilisateurs sur une connexion 4G
2. **EX-SEC-001**: Toutes les communications entre le client et le serveur doivent utiliser TLS 1.3 minimum
   **EX-SEC-002**: Les mots de passe doivent √™tre hash√©s avec bcrypt (facteur de co√ªt minimum 12)
3. **EX-UTIL-001**: Un nouvel utilisateur doit pouvoir effectuer sa premi√®re action m√©tier (ex: cr√©er un document) en moins de 3 clics apr√®s connexion
   **EX-UTIL-002**: L'interface doit √™tre conforme aux crit√®res WCAG 2.1 niveau AA
</details>

### Exercice 3: Mod√©lisation m√©tier

Pour un syst√®me de r√©servation de restaurant en ligne:

1. Listez 5 exigences fonctionnelles
2. Listez 3 exigences non fonctionnelles
3. Identifiez les entit√©s principales du domaine
4. D√©finissez 2 r√®gles m√©tier importantes

<details>
<summary>üí° Solution (exemple)</summary>

**Exigences fonctionnelles:**
- EX-FUNC-001: Le client doit pouvoir rechercher un restaurant par nom, ville ou type de cuisine
- EX-FUNC-002: Le client doit pouvoir r√©server une table en sp√©cifiant date, heure et nombre de convives
- EX-FUNC-003: Le syst√®me doit envoyer un email de confirmation de r√©servation
- EX-FUNC-004: Le restaurant doit pouvoir visualiser ses r√©servations par jour
- EX-FUNC-005: Le restaurant doit pouvoir confirmer ou annuler une r√©servation

**Exigences non fonctionnelles:**
- EX-PERF-001: Le syst√®me doit supporter 1000 r√©servations simultan√©es
- EX-SEC-001: Les donn√©es de paiement doivent √™tre conformes PCI-DSS
- EX-DISP-001: Le syst√®me doit avoir une disponibilit√© de 99.5%

**Entit√©s:**
- Restaurant
- Client
- R√©servation
- Table
- Cr√©neau horaire

**R√®gles m√©tier:**
- RG-001: Une r√©servation ne peut √™tre effectu√©e que si au moins une table est disponible pour le cr√©neau demand√©
- RG-002: Une r√©servation non confirm√©e par le restaurant dans les 2 heures est automatiquement annul√©e
</details>

---

## üìö Pour aller plus loin

### Lectures recommand√©es

- üìñ **"Software Engineering"** - Ian Sommerville (r√©f√©rence sur les cycles de vie)
- üìñ **"Domain-Driven Design"** - Eric Evans (la bible du DDD)
- üìñ **"User Stories Applied"** - Mike Cohn (gestion agile des exigences)
- üìñ **"Writing Effective Use Cases"** - Alistair Cockburn

### Normes et standards

- **IEEE 830-1998**: Pratiques recommand√©es pour les sp√©cifications d'exigences logicielles
- **ISO/IEC 12207**: Processus du cycle de vie du logiciel
- **SWEBOK**: Software Engineering Body of Knowledge

### Outils

- **Gestion d'exigences**: Jira, Azure DevOps, IBM DOORS, Polarion
- **Mod√©lisation**: Enterprise Architect, Visual Paradigm, StarUML
- **Prototypage**: Figma, Adobe XD, Balsamiq, Sketch
- **Collaboration**: Miro, Mural (pour Event Storming)

---

[‚¨ÖÔ∏è Retour √† la Partie I](./README.md) | [‚û°Ô∏è Chapitre 2: Analyse des besoins](./chapitre-2-analyse-besoins-specifications.md)

